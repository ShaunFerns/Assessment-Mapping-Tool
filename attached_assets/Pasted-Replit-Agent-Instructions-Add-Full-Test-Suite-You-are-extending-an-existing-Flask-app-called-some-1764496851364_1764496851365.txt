Replit Agent Instructions – Add Full Test Suite

You are extending an existing Flask app called something like app.py with in-memory data structures:

programme – dict with "name" and "weeks"

modules – list of dicts

assessments – list of dicts

Flask routes: /, /programme, /modules, /assessments, /visual/triangle, /visual/heatmap, /visual/analytics

Your task is to:

Add pure helper functions for core logic.

Add a pytest-based test suite covering:

Core data/analytics logic

Basic route smoke tests

Ensure tests are easy to run with pytest.

1. Update dependencies

In requirements.txt, make sure the following are present:

Flask==3.0.3
pandas==2.2.2
plotly==5.23.0
pytest==8.3.3


(If versions differ slightly, keep them consistent with the current file.)

2. Refactor core analytics logic into helper functions

In app.py, you currently compute analytics values directly inside the /visual/analytics route. Refactor that logic into pure functions at module level so they can be unit-tested.

Add these functions near the top or below the globals:

# Global state (already exists)
programme = {}
modules = []
assessments = []

def reset_state():
    """Reset global in-memory state. Used by tests."""
    global programme, modules, assessments
    programme = {}
    modules = []
    assessments = []


def compute_weekly_load(programme_dict, assessments_list):
    """Return (weeks, weekly_load_list) based on programme weeks & assessment weights."""
    weeks_count = programme_dict.get("weeks", 0)
    weeks = list(range(1, weeks_count + 1))
    weekly_load = [0] * weeks_count
    for a in assessments_list:
        w = a.get("week")
        weight = a.get("weight", 0)
        if isinstance(w, int) and 1 <= w <= weeks_count:
            weekly_load[w - 1] += weight
    return weeks, weekly_load


def compute_type_distribution(assessments_list):
    """Return (type_labels, type_values) of total weight per assessment type."""
    type_labels = ["Delivery", "Presentation", "Exam", "Report", "Case Study"]
    type_map = {t.lower(): 0 for t in type_labels}
    for a in assessments_list:
        atype = (a.get("atype") or "").lower()
        weight = a.get("weight", 0)
        if atype in type_map:
            type_map[atype] += weight
    type_values = [type_map[t.lower()] for t in type_labels]
    return type_labels, type_values


def compute_module_profiles(modules_list, assessments_list):
    """Return (module_labels, total_weights, counts) for each module."""
    module_labels = [m.get("code") for m in modules_list]
    total_weights = [0] * len(modules_list)
    counts = [0] * len(modules_list)

    module_index = {m["id"]: idx for idx, m in enumerate(modules_list) if "id" in m}
    for a in assessments_list:
        mid = a.get("module_id")
        weight = a.get("weight", 0)
        idx = module_index.get(mid)
        if idx is not None:
            total_weights[idx] += weight
            counts[idx] += 1
    return module_labels, total_weights, counts


def compute_ga_coverage(assessments_list):
    """Return (ga_labels, ga_totals) based on GA strings like 'People', 'Planet', 'Partnership'."""
    ga_labels = ["People", "Planet", "Partnership"]
    ga_totals = [0, 0, 0]
    for a in assessments_list:
        ga = (a.get("ga") or "").strip().lower()
        weight = a.get("weight", 0)
        for i, label in enumerate(ga_labels):
            if label.lower() in ga:
                ga_totals[i] += weight
    return ga_labels, ga_totals


def compute_stress_values(weekly_load):
    """Return a copy of weekly_load. Kept separate for future extensions."""
    return list(weekly_load)


Now update the /visual/analytics route to use these functions:

@app.route("/visual/analytics")
def visual_analytics():
    if not programme or not modules or not assessments:
        return render_template("visual_analytics.html", no_data=True)

    weeks, weekly_load = compute_weekly_load(programme, assessments)
    type_labels, type_values = compute_type_distribution(assessments)
    module_labels, module_total_weight, module_assessment_count = compute_module_profiles(modules, assessments)
    ga_labels, ga_totals = compute_ga_coverage(assessments)
    stress_values = compute_stress_values(weekly_load)

    return render_template(
        "visual_analytics.html",
        no_data=False,
        weeks=weeks,
        weekly_load=weekly_load,
        type_labels=type_labels,
        type_values=type_values,
        module_labels=module_labels,
        module_total_weight=module_total_weight,
        module_assessment_count=module_assessment_count,
        ga_labels=ga_labels,
        ga_totals=ga_totals,
        stress_values=stress_values,
    )

3. Add a tests/ directory

Create a new folder:

tests/
  __init__.py
  test_core_logic.py
  test_routes.py


tests/__init__.py can be an empty file.

4. Core logic tests – tests/test_core_logic.py

Create this file with unit tests for the helper functions. Use pytest.

import pytest

from app import (
    reset_state,
    programme,
    modules,
    assessments,
    compute_weekly_load,
    compute_type_distribution,
    compute_module_profiles,
    compute_ga_coverage,
    compute_stress_values,
)


@pytest.fixture(autouse=True)
def clean_state():
    """Reset global state before each test."""
    reset_state()
    yield
    reset_state()


def setup_basic_programme():
    programme.clear()
    programme.update({"name": "Test Programme", "weeks": 6})
    modules.clear()
    assessments.clear()

    modules.extend([
        {"id": 1, "code": "MOD101", "title": "Module 101"},
        {"id": 2, "code": "MOD102", "title": "Module 102"},
    ])

    assessments.extend([
        {
            "id": 1,
            "module_id": 1,
            "week": 1,
            "weight": 20,
            "atype": "Delivery",
            "mode": "individual",
            "plo": "PLO1",
            "mlo": "MLO1",
            "ga": "People",
        },
        {
            "id": 2,
            "module_id": 1,
            "week": 3,
            "weight": 30,
            "atype": "Exam",
            "mode": "group",
            "plo": "PLO2",
            "mlo": "MLO2",
            "ga": "Planet",
        },
        {
            "id": 3,
            "module_id": 2,
            "week": 3,
            "weight": 50,
            "atype": "Report",
            "mode": "individual",
            "plo": "PLO1",
            "mlo": "MLO3",
            "ga": "Partnership",
        },
    ])


def test_compute_weekly_load_basic():
    setup_basic_programme()
    weeks, weekly_load = compute_weekly_load(programme, assessments)

    assert weeks == [1, 2, 3, 4, 5, 6]
    # Week 1: 20, Week 3: 30 + 50 = 80, others 0
    assert weekly_load == [20, 0, 80, 0, 0, 0]


def test_compute_type_distribution_basic():
    setup_basic_programme()
    labels, values = compute_type_distribution(assessments)
    # We know we used Delivery (20), Exam (30), Report (50)
    type_map = dict(zip(labels, values))

    assert type_map["Delivery"] == 20
    assert type_map["Exam"] == 30
    assert type_map["Report"] == 50
    # Unused types should be 0
    assert type_map["Presentation"] == 0
    assert type_map["Case Study"] == 0


def test_compute_module_profiles_basic():
    setup_basic_programme()
    module_labels, total_weights, counts = compute_module_profiles(modules, assessments)

    assert module_labels == ["MOD101", "MOD102"]

    # MOD101 (id 1) has assessments 20 + 30
    assert total_weights[0] == 50
    assert counts[0] == 2

    # MOD102 (id 2) has assessment 50
    assert total_weights[1] == 50
    assert counts[1] == 1


def test_compute_ga_coverage_basic():
    setup_basic_programme()
    ga_labels, ga_totals = compute_ga_coverage(assessments)
    ga_map = dict(zip(ga_labels, ga_totals))

    # We created 20 for People, 30 for Planet, 50 for Partnership
    assert ga_map["People"] == 20
    assert ga_map["Planet"] == 30
    assert ga_map["Partnership"] == 50


def test_compute_weekly_load_ignores_out_of_range_weeks():
    setup_basic_programme()
    # Add an invalid week assessment
    assessments.append({
        "id": 4,
        "module_id": 1,
        "week": 99,   # out of range
        "weight": 100,
        "atype": "Exam",
        "mode": "individual",
        "plo": "PLO3",
        "mlo": "MLO4",
        "ga": "People",
    })

    weeks, weekly_load = compute_weekly_load(programme, assessments)
    assert 99 not in weeks
    # Total load for valid weeks unchanged by the out-of-range entry
    assert weekly_load == [20, 0, 80, 0, 0, 0]


def test_compute_stress_values_is_copy():
    setup_basic_programme()
    _, weekly_load = compute_weekly_load(programme, assessments)
    stress = compute_stress_values(weekly_load)

    assert stress == weekly_load
    # Ensure it is a copy, not the same list
    assert stress is not weekly_load

5. Route smoke tests – tests/test_routes.py

Now add basic Flask route tests to confirm key pages load successfully.

import pytest
from app import app, reset_state, programme, modules, assessments


@pytest.fixture
def client():
    reset_state()
    app.config["TESTING"] = True
    with app.test_client() as client:
        yield client
    reset_state()


def setup_minimum_programme_state():
    programme.clear()
    programme.update({"name": "Test Programme", "weeks": 4})
    modules.clear()
    assessments.clear()

    modules.extend([
        {"id": 1, "code": "MOD101", "title": "Module 101"},
    ])

    assessments.extend([
        {
            "id": 1,
            "module_id": 1,
            "week": 2,
            "weight": 50,
            "atype": "Exam",
            "mode": "individual",
            "plo": "PLO1",
            "mlo": "MLO1",
            "ga": "People",
        }
    ])


def test_home_route_ok(client):
    response = client.get("/")
    assert response.status_code == 200
    assert b"Assessment" in response.data or b"Programme" in response.data


def test_programme_route_get_ok(client):
    response = client.get("/programme")
    assert response.status_code == 200


def test_modules_route_get_ok(client):
    response = client.get("/modules")
    assert response.status_code == 200


def test_assessments_route_get_ok(client):
    response = client.get("/assessments")
    assert response.status_code == 200


def test_visual_triangle_requires_data(client):
    # Without programme/modules/assessments we still expect a response, not crash
    response = client.get("/visual/triangle")
    assert response.status_code == 200


def test_visual_heatmap_requires_data(client):
    response = client.get("/visual/heatmap")
    assert response.status_code == 200


def test_visual_analytics_no_data(client):
    response = client.get("/visual/analytics")
    assert response.status_code == 200
    # no_data branch should show a friendly message
    assert b"Add a programme" in response.data or b"at least one assessment" in response.data


def test_visual_analytics_with_data(client):
    setup_minimum_programme_state()
    response = client.get("/visual/analytics")
    assert response.status_code == 200
    # Check that chart containers are present
    assert b"chart-weekly-load" in response.data
    assert b"chart-type-balance" in response.data
    assert b"chart-module-profile" in response.data
    assert b"chart-ga-coverage" in response.data
    assert b"chart-stress-map" in response.data


If your templates use slightly different wording for the “no data” message, adjust the assert text accordingly.

6. How to run tests

In the Replit shell, you should now be able to run:

pytest


or

pytest -q


and see all tests pass.